% Unified Notation for Oblivious Computing Series
% Focus: Precisely specifying WHICH parts are oblivious

% ============================================
% Basic Types (needed for Bernoulli references)
% ============================================

\providecommand{\Bool}{\mathbb{B}}
\providecommand{\True}{\mathtt{true}}
\providecommand{\False}{\mathtt{false}}
\providecommand{\Bernoulli}[2]{\mathcal{B}^{#2}(#1)}  % Bernoulli type constructor
\providecommand{\BF}{\mathsf{BF}}  % Bloom Filter notation
\providecommand{\Enc}[1]{\mathsf{Enc}(#1)}  % Encryption notation
\providecommand{\Universe}{\mathcal{U}}  % Universal set
\providecommand{\SI}[2]{\mathsf{SI}(#1, #2)}  % Secure Index
\providecommand{\MutInfo}[2]{I(#1 ; #2)}  % Mutual Information
\providecommand{\Info}[1]{H(#1)}  % Information/Entropy
\providecommand{\CondInfo}[2]{H(#1 | #2)}  % Conditional Entropy
\providecommand{\Prob}[1]{\mathbb{P}\left[#1\right]}  % Probability
\providecommand{\Adv}{\mathcal{A}}  % Adversary
\providecommand{\negl}{\mathsf{negl}}  % Negligible function
\providecommand{\Token}[1]{\mathsf{Token}(#1)}  % Tokenization function
\providecommand{\PRF}{\mathsf{PRF}}  % Pseudo-random function

% ============================================
% Core Oblivious Type Constructors
% ============================================

% Basic oblivious wrapper - makes entire type oblivious
\providecommand{\Obv}[1]{\mathcal{O}\langle #1 \rangle}

% Partial oblivious - only specific components are oblivious
% Examples:
%   (T, \Obv{U}) - second component oblivious
%   \Obv{(T, U)} - entire tuple oblivious (entangled)
%   (\Obv{T}, \Obv{U}) - both components independently oblivious

% ============================================
% Granularity Markers
% ============================================

% Component-level oblivious (independent)
\providecommand{\ObvComp}[1]{\mathcal{O}_c\langle #1 \rangle}

% Structure-level oblivious (entangled)
\providecommand{\ObvStruct}[1]{\mathcal{O}_s\langle #1 \rangle}

% Type-level oblivious (even the type itself is hidden)
\providecommand{\ObvType}[1]{\mathcal{O}_t\langle #1 \rangle}

% ============================================
% Oblivious Product Types
% ============================================

% Independent oblivious components
\providecommand{\ObvProd}[2]{(\Obv{#1}, \Obv{#2})}

% Entangled oblivious pair
\providecommand{\ObvPair}[2]{\Obv{(#1, #2)}}

% Mixed oblivious (first clear, second oblivious)
\providecommand{\MixedProd}[2]{(#1, \Obv{#2})}

% ============================================
% Oblivious Sum Types
% ============================================

% Tag is clear, value is oblivious
\providecommand{\ObvSum}[2]{#1 + \Obv{#2}}

% Both tag and value are oblivious
\providecommand{\ObvTagSum}[2]{\Obv{(#1 + #2)}}

% ============================================
% Oblivious Function Types
% ============================================

% Function with oblivious output
\providecommand{\ObvOut}[2]{#1 \to \Obv{#2}}

% Function with oblivious input
\providecommand{\ObvIn}[2]{\Obv{#1} \to #2}

% Fully oblivious function
\providecommand{\ObvFun}[2]{\Obv{(#1 \to #2)}}

% Oblivious function application
\providecommand{\ObvApp}[2]{\Obv{#1}(#2)}

% ============================================
% Oblivious Collections
% ============================================

% Oblivious set - membership is oblivious
\providecommand{\ObvSet}[1]{\Obv{\mathcal{P}(#1)}}

% Set of oblivious elements
\providecommand{\SetObv}[1]{\mathcal{P}(\Obv{#1})}

% Oblivious map - lookups are oblivious
\providecommand{\ObvMap}[2]{\Obv{(#1 \to #2)}}

% Map with oblivious values
\providecommand{\MapObv}[2]{#1 \to \Obv{#2}}

% ============================================
% Access Patterns and Leakage
% ============================================

% What leaks from accessing x
\providecommand{\Leak}[1]{\mathcal{L}(#1)}

% Access pattern for operation
\providecommand{\Pattern}[1]{\pi(#1)}

% Observable trace
\providecommand{\Trace}[1]{\tau(#1)}

% Hidden value
\providecommand{\Hidden}[1]{\mathsf{h}(#1)}

% Revealed/Observable value
\providecommand{\Reveal}[1]{\tilde{#1}}

% ============================================
% Leakage Specifications
% ============================================

% No leakage
\providecommand{\NoLeak}{\bot}

% Size leakage only
\providecommand{\SizeLeak}{\mathsf{size}}

% Pattern leakage
\providecommand{\PatternLeak}{\mathsf{pattern}}

% Full leakage
\providecommand{\FullLeak}{\top}

% ============================================
% Examples of Notation Usage
% ============================================

% Example 1: Oblivious map returning tuple
% \ObvMap{K}{(T, U)} - entire map is oblivious, returns clear tuple
% K \to \Obv{(T, U)} - clear map, returns oblivious tuple
% K \to (\Obv{T}, \Obv{U}) - clear map, returns tuple with both components oblivious
% \ObvMap{K}{(\Obv{T}, U)} - oblivious map, returns tuple with first component oblivious

% Example 2: Nested oblivious structures
% \Obv{\Obv{T}} - double oblivious (observation of an observation)
% \ObvSet{\ObvPair{T}{U}} - oblivious set of oblivious pairs
% \SetObv{(T, U)} - clear set of oblivious tuples

% ============================================
% Composition Rules
% ============================================

% Leakage composition (sequential)
\providecommand{\LeakSeq}[2]{\Leak{#1} \oplus \Leak{#2}}

% Leakage composition (parallel)
\providecommand{\LeakPar}[2]{\Leak{#1} \parallel \Leak{#2}}

% Leakage bound
\providecommand{\LeakBound}[2]{\Leak{#1} \leq #2}

% ============================================
% Security Definitions
% ============================================

% Indistinguishability
\providecommand{\Indist}{\approx}
\providecommand{\CompIndist}{\approx_c}
\providecommand{\StatIndist}{\approx_s}

% Security parameter
\providecommand{\SecParam}{\lambda}

% Negligible function
\providecommand{\Negl}[1]{\mathsf{negl}(#1)}

% ============================================
% Common Patterns
% ============================================

% Searchable encryption pattern
\providecommand{\SearchEnc}[2]{\ObvMap{#1}{#2}}

% PIR pattern (oblivious index, clear value)
\providecommand{\PIR}[2]{\ObvIn{#1}{#2}}

% ORAM pattern (oblivious address, oblivious value)
\providecommand{\ORAM}[2]{\ObvFun{#1}{#2}}

% ============================================
% Notation Guide Box
% ============================================

\providecommand{\ObliviousNotationGuide}{%
\begin{center}
\fbox{
\begin{minipage}{0.9\textwidth}
\textbf{Oblivious Type Notation Guide}\\[0.5em]
\begin{tabular}{ll}
\textbf{Notation} & \textbf{Meaning} \\
\hline
$\Obv{T}$ & Type $T$ is oblivious \\
$(T, \Obv{U})$ & Tuple with second component oblivious \\
$\Obv{(T, U)}$ & Entire tuple is oblivious (entangled) \\
$(\Obv{T}, \Obv{U})$ & Both components independently oblivious \\
$\ObvMap{K}{V}$ & Oblivious map (lookups don't leak) \\
$K \to \Obv{V}$ & Clear map with oblivious values \\
$\Leak{x} = \NoLeak$ & Operation on $x$ leaks nothing \\
$\Leak{x} = \SizeLeak$ & Operation on $x$ leaks size only \\
\end{tabular}
\end{minipage}
}
\end{center}
}
